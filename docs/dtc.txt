	public static boolean parse(byte[] buffer, HarleyData hd) {
		byte[] in;
		int x;
		int y;

		in = bytes_to_hex(buffer);

		/*
		System.out.print("BUF: ");
		for (int i = 0; i < in.length; i++)
			System.out.print(Integer.toHexString(in[i]) + " ");
		System.out.println("");
		 */

		if (crc(in) != (byte)0xc4) {
			hd.setBadCRC(buffer);
			return false;
		}

		x = y = 0;
		if (in.length >= 4)
			x = ((in[0] << 24) & 0xff000000) |
			    ((in[1] << 16) & 0x00ff0000) |
			    ((in[2] <<  8) & 0x0000ff00) |
			     (in[3]        & 0x000000ff);
		if (in.length >= 6)
			y = ((in[4] << 8) & 0x0000ff00) |
			     (in[5]       & 0x000000ff);

		if (x == 0x281b1002) {
			hd.setRPM(y);
		} else if (x == 0x48291002) {
			hd.setSpeed(y);
		} else if (x == 0xa8491010) {
			hd.setEngineTemp((int)in[4] & 0xff);
		} else if (x == 0xa83b1003) {
			if (in[4] != 0) {
				int gear = 0;
				while ((in[4] >>= 1) != 0)
					gear++;
				hd.setGear(gear);
			} else
				hd.setGear(-1);
		} else if ((x == 0x48da4039) && ((in[4] & 0xfc) == 0)) {
			hd.setTurnSignals(in[4] & 0x03);
		} else if ((x & 0xffffff7f) == 0xa8691006) {
			odolast = y - odolast;
			if (odolast < 0)	// ...could also test for (x & 0x80)
				odolast += 65536;
			odoaccum += odolast;
			odolast = y;
			hd.setOdometer(odoaccum);
		} else if ((x & 0xffffff7f) == 0xa883100a) {
			fuellast = y - fuellast;
			if (fuellast < 0)	// ...could also test for (x & 0x80)
				fuellast += 65536;
			fuelaccum += fuellast;
			fuellast = y;
			hd.setFuel(fuelaccum);
		} else if ((x & 0xffffff7f) == 0xa8836112) {
			hd.setFuelGauge(in[4] & 0x0f,
					((in[3] & 0x80) != 0) ? true : false);
		} else if ((x & 0xffffff5d) == 0x483b4000) {
			if (((int)in[3] & 0xff) == 0x20)
				hd.setNeutral(false);
			else if (((int)in[3] & 0xff) == 0xA0)
				hd.setNeutral(true);
			hd.setClutch((in[3] & 0x80) != 0);
		} else if ((x & 0xffffff7f) == 0x68881003) {
			if ((in[3] & 0x80) != 0)
				hd.setCheckEngine(true);
			else
				hd.setCheckEngine(false);
		} else if (x == 0x0c10f13c) {
			/* this is the read block command, answers are below... */
		} else if (x == 0x0cf1107c) {
			switch (in[4]) {
			case 0x01:
				System.arraycopy(in, 5, ecmPN, 0, 6);
				hd.setECMPN(new String(ecmPN).trim());
				break;
			case 0x02:
				System.arraycopy(in, 5, ecmPN, 6, 6);
				hd.setECMPN(new String(ecmPN).trim());
				break;
			case 0x03:
				System.arraycopy(in, 5, ecmCalID, 0, 6);
				hd.setECMCalID(new String(ecmCalID).trim());
				break;
			case 0x04:
				System.arraycopy(in, 5, ecmCalID, 6, 6);
				hd.setECMCalID(new String(ecmCalID).trim());
				break;
			case 0x0b:
				hd.setECMSWLevel((int)in[5] & 0xff);
				break;
			case 0x0f:
				System.arraycopy(in, 5, vin, 0, 6);
				hd.setVIN(new String(vin).trim());
				break;
			case 0x10:
				System.arraycopy(in, 5, vin, 6, 6);
				hd.setVIN(new String(vin).trim());
				break;
			case 0x11:
				System.arraycopy(in, 5, vin, 12, 5);
				hd.setVIN(new String(vin).trim());
				break;
			default:
				hd.setUnknown(buffer);
			}
		} else if ((x & 0xff0fffff) == 0x6c00f119) {
			/* this is the get DTC command, answers are below... */
			if (D) Log.d(TAG, "DTC start");
		} else if ((x & 0xffff0fff) == 0x6cf10059) {
			if (in[4] != 0 || in[5] != 0) {
				String dtc = "";
				switch ((in[4] & 0xc0) >> 6) {
					case 0: dtc = "P"; break;
					case 1: dtc = "C"; break;
					case 2: dtc = "B"; break;
					case 3: dtc = "U"; break;
				}
				dtc += Integer.toString((in[4] & 0x30) >> 4, 16);
				dtc += Integer.toString(in[4] & 0x0f, 16);
				dtc += Integer.toString((in[5] & 0xf0) >> 4, 16);
				dtc += Integer.toString(in[5] & 0x0f, 16);
				dtc = dtc.toUpperCase();
				if (in[2] == 0x10) {
					/* historic DTC */
					if (D) Log.d(TAG, "historic DTC: " + dtc);
					hd.addHistoricDTC(dtc);
				} else if (in[2] == 0x40) {
					/* current DTC */
					if (D) Log.d(TAG, "current DTC: " + dtc);
					hd.addCurrentDTC(dtc);
				} else
					hd.setUnknown(buffer);
			}
		} else if ((x & 0xff0fffff) == 0x6c00f114) {
			if (D) Log.d(TAG, "DTC clear request");
		} else if ((x & 0xffff0fff) == 0x6cf10054) {
			if (D) Log.d(TAG, "DTC clear reply");
		} else
			hd.setUnknown(buffer);
		return true;
	}
	
	
	
	
	
	
		public void clearDTC() {
		if (D) Log.d(TAG, "clearDTC()");

		String[] cTypes =		{ "6C", "6C", "6C" };
		String[] cTas =			{ "10", "40", "60" };
		String[] cSas =			{ "F1", "F1", "F1" };
		String[] cCommands =	{ "14", "14", "14" };
		String[] cExpects =		{ "6CF11054", "6CF14054", "6CF16054" };
		int[] cCommandTimeout =	{ CLEAR_DTC_TIMEOUT, CLEAR_DTC_TIMEOUT, CLEAR_DTC_TIMEOUT };

		if (mService != null)
			mService.setSendData(cTypes, cTas, cSas, cCommands, cExpects, cCommandTimeout, COMMAND_DELAY);

		mHandler.postDelayed(mRestartTask, CLEAR_DTC_DELAY);
	}



AT SH 6C xx F1	the AT command that need to be sent
AT SH 6C 10 F1	10 = ECM (main engine brain)
AT SH 6C 28 F1	28 = ABS
AT SH 6C 40 F1	40 = BCM (body control module)
AT SH 6C 58 F1	58 = Airbag Module
AT SH 6C 60 F1	60 = IPC (instument panel cluster)
AT SH 6C 62 F1	62 = Hud
AT SH 6C 80 F1	80 = Radio
AT SH 6C C0 F1	C0 = Immobilizer
19 C2 FF 00	Current Codes
19 D2 FF 00	Current and Pending Codes
6C F1 58 59 81 00 13 99	This is a response.
AA BB CC DD EF GH IJ KL	
AA = Node to node​
	
BB = Adress to scanner you're using​
	
CC= Witch part the code is located in. Engine,trans,abs,airbag m.m.​
	
DD= This I'm not sure about​
	
E = First part of the code​
	
F = Second part of the code​
	
G = Third part of the code​
	
H = Fourth part of the code​
	
IJ= Status of the code 00=god 11=and up eq.fault​
	
KL= Checksum of the code just ignore this one​
	
 
 
 Finally i figured this one out

First you got to turn on all headers by sending command

AT h1

Then you got to tell the ELM witch computer you
wish to talk to... In my case 58 (airbag module)

So you send command

AT SH 6C 58 F1

When you sent this you will recive OK
Next line to sent is one of the following
19 c2 ff 00 with this you will get current codes
19 d2 ff 00 with this you will current and pending codes (I used this)

Got this code in return

6C F1 58 59 81 00 13 99
AA BB CC DD EF GH IJ KL

AA = Node to node
BB = Adress to scanner you're using
CC= Witch part the code is located in. Engine,trans,abs,airbag m.m.
DD= This I'm not sure about
E = First part of the code
F = Second part of the code
G = Third part of the code
H = Fourth part of the code
IJ= Status of the code 00=god 11=and up eq.fault
KL= Checksum of the code just ignore this one

4 = C0
5 = C1
6 = C2

8 = B0
9 = B1
A = B2

D = U1
E = U2

So my code to translate EFGH in the message above.
81 00 = B0100 You replace number 8 with B0 in my case.

So my code would be Bodycode B0100=Electronic front end sensor 1 performance

You will also get a code that says 00 00 on the next line.
It means something like end of message.
Below a good site with lots of obd codes
OBD II Body Trouble Code Chart

10 = ecm (main engine brain)
28 = abs
40 = bcm (body control module)
58 = airbag module
60 = IPC (instument panel cluster)
62 = hud
80 = radio
c0 = immobilizer

The letters CC in the code above tells you witch part the codes are from or
you wish to talk when you're sending you're command.
Sometimes you'll get a lot of codes so the easy way is to adress each part
at a time and ask for trouble codes.
There should be one for CC code for the transmission also, but haven't figured that one out yet. Anybody knows feel free to complete this list.

If you turn on all headers and send the command 19 d2 ff 00, it's not always
all parts will respond. For an example the BCM and airbag module won't respond.

When you send the command 14, you will erase all codes!!






